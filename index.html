---
layout: default
title: Home
---

<div class="home">
  <div class="hero-section">
    <!-- <h1 class="site-title">{{ site.title | default: "timsonner.com" }}</h1> -->
    <p class="site-description">{{ site.description | default: "timsonner.com" }}</p>
    <div id="visitor-info" class="visitor-info">
      <span id="visitor-greeting">Welcome, visitor!</span>
    </div>
  </div>

  <!-- Terminal Emulator Section -->
  <div class="terminal-section">
    <div class="terminal-header">
      <span class="terminal-button red"></span>
      <span class="terminal-button yellow"></span>
      <span class="terminal-button green"></span>
      <span class="terminal-title">guest@timsonner.com:~</span>
      <button id="copy-terminal-btn" class="copy-code-button" style="position: static; margin-left: auto; padding: 2px 8px;">Copy</button>
    </div>
    <div class="terminal-window" id="terminal-window" onclick="document.getElementById('terminal-input').focus()">
      <div class="terminal-output" id="terminal-output">
        <div class="terminal-line">Welcome to TimSonner.com Terminal v1.0.0</div>
        <div class="terminal-line">Type 'help' to see available commands.</div>
        <br>
      </div>
      <div class="terminal-input-line">
        <span class="terminal-prompt">guest@timsonner.com:~$</span>
        <input type="text" id="terminal-input" class="terminal-input" autocomplete="off" spellcheck="false">
      </div>
    </div>
  </div>

  <div class="posts-section">
    <h2>Latest Posts</h2>
    <ul class="post-list">
      {% for post in site.posts %}
        <li class="post-item">
          {% if post.featured_image %}
            <div class="post-image">
              <a href="{{ post.url | relative_url }}">
                <img src="{{ post.featured_image }}" alt="{{ post.title | escape }}" />
              </a>
            </div>
          {% endif %}
          <div class="post-content-preview">
            <span class="post-meta">{{ post.date | date: "%b %-d, %Y" }}</span>
            <h3>
              <a class="post-link" href="{{ post.url | relative_url }}">
                {{ post.title | escape }}
              </a>
            </h3>
            {% if post.excerpt %}
              <p class="post-excerpt">{{ post.excerpt | strip_html | truncatewords: 30 }}</p>
            {% endif %}
          </div>
        </li>
      {% endfor %}
    </ul>
  </div>
</div>

<script>
// Fetch visitor IP and location information
async function fetchVisitorInfo() {
  const greetingElement = document.getElementById('visitor-greeting');
  
  try {
    const response = await fetch('https://ipapi.co/json/');
    const data = await response.json();
    
    if (data.ip && data.city && data.region) {
      const location = `${data.city}, ${data.region}`;
      const userAgent = navigator.userAgent;

      greetingElement.innerHTML = `
        <span class="info-item">Visitor: ${data.ip}</span>
        <span class="info-separator">|</span>
        <span class="info-item">Location: ${location}</span>
        <span class="info-separator">|</span>
        <span class="info-item">Data: <a href="https://ipapi.co" target="_blank">ipapi.co</a></span>
        <span class="info-item">UA: ${userAgent}</span>
      `;

    } else {
      greetingElement.innerHTML = 'Welcome, visitor!';
    }
  } catch (error) {
    console.log('Could not fetch visitor info:', error);
    greetingElement.innerHTML = 'Welcome to my blog!';
  }
}

// Load visitor info when page loads
document.addEventListener('DOMContentLoaded', fetchVisitorInfo);
</script>

<script>
// Terminal Emulator Logic
document.addEventListener('DOMContentLoaded', function() {
  const terminalInput = document.getElementById('terminal-input');
  const terminalOutput = document.getElementById('terminal-output');
  const terminalWindow = document.getElementById('terminal-window');

  // Copy Terminal Button Logic
  const copyBtn = document.getElementById('copy-terminal-btn');
  if (copyBtn) {
    copyBtn.addEventListener('click', function() {
      const textToCopy = terminalOutput.innerText;
      if (window.copyToClipboard) {
        window.copyToClipboard(textToCopy, copyBtn);
      } else {
        console.error('copyToClipboard function not found');
      }
    });
  }

  terminalInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      const input = terminalInput.value;
      processCommand(input);
      terminalInput.value = '';
    }
  });

  function processCommand(input) {
    const parts = input.trim().split(/\s+/);
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);

    // Add command to output
    addToOutput(`guest@timsonner.com:~$ ${input}`);

    if (input.trim() === '') return;

    switch(command) {
      case 'help':
        addToOutput('Available commands: help, date, clear, whois, dig, osint');
        break;
      case 'date':
        addToOutput(new Date().toString());
        break;
      case 'clear':
        terminalOutput.innerHTML = '';
        break;
      case 'whois':
        handleWhois(args);
        break;
      case 'dig':
        handleDig(args);
        break;
      case 'osint':
        handleOsint(args);
        break;
      default:
        addToOutput(`Command not found: ${command}`, 'command-error');
    }
    
    // Scroll to bottom
    terminalWindow.scrollTop = terminalWindow.scrollHeight;
  }

  function addToOutput(text, className = '') {
    const div = document.createElement('div');
    div.className = `terminal-line ${className}`;
    div.textContent = text;
    terminalOutput.appendChild(div);
  }

  async function handleWhois(args) {
    if (args.length === 0) {
      addToOutput('Usage: whois <domain>');
      return;
    }
    
    const domain = args[0];
    addToOutput(`Querying RDAP for ${domain}...`);
    
    try {
      const response = await fetch(`https://rdap.org/domain/${domain}`);
      
      if (!response.ok) {
        if (response.status === 404) {
          addToOutput(`Domain '${domain}' not found or TLD not supported.`, 'command-error');
        } else {
          addToOutput(`Error querying domain: ${response.status}`, 'command-error');
        }
        return;
      }
      
      const data = await response.json();
      
      // Format Output
      addToOutput('----------------------------------------');
      addToOutput(`Domain Name: ${data.ldhName || data.handle}`);
      if (data.handle) addToOutput(`Registry Domain ID: ${data.handle}`);
      
      if (data.status) {
        addToOutput(`Status: ${data.status.join(', ')}`);
      }
      
      if (data.secureDNS) {
         addToOutput(`DNSSEC: ${data.secureDNS.delegationSigned ? 'signedDelegation' : 'unsigned'}`);
      }
      
      if (data.events) {
        data.events.forEach(event => {
          let date = new Date(event.eventDate).toISOString().split('T')[0];
          addToOutput(`${event.eventAction}: ${date}`);
        });
      }
      
      if (data.nameservers) {
        const ns = data.nameservers.map(n => n.ldhName).join(', ');
        addToOutput(`Name Servers: ${ns}`);
      }
      
      // Process Entities (Registrar, Registrant, Admin, etc.)
      if (data.entities) {
        addToOutput(''); // Spacer
        processEntities(data.entities);
      }
      
      // Notices
      if (data.notices) {
        addToOutput('');
        data.notices.forEach(notice => {
           if (notice.title) addToOutput(`Notice: ${notice.title}`);
           if (notice.description) notice.description.forEach(d => addToOutput(`  ${d}`));
        });
      }
      
      addToOutput('----------------------------------------');
      addToOutput('Data provided by rdap.org');
      
    } catch (error) {
      addToOutput(`Network error: ${error.message}`, 'command-error');
    }
    
    // Scroll to bottom after async operation
    terminalWindow.scrollTop = terminalWindow.scrollHeight;
  }

  async function handleDig(args) {
    if (args.length === 0) {
      addToOutput('Usage: dig <domain> [type] (default: A)');
      addToOutput('       Types: A, AAAA, CNAME, MX, TXT, NS, SOA');
      addToOutput('       dig <domain> DMARC');
      addToOutput('       dig <selector>._domainkey.<domain> DKIM');
      return;
    }

    let domain = args[0];
    let type = args[1] ? args[1].toUpperCase() : 'A';

    // Special handling for DMARC
    if (type === 'DMARC') {
        if (!domain.startsWith('_dmarc.')) {
            domain = '_dmarc.' + domain;
        }
        type = 'TXT';
        addToOutput(`; (Pseudo-type DMARC maps to ${domain} IN TXT)`);
    }

    // Special handling for DKIM
    if (type === 'DKIM') {
        addToOutput('; For DKIM, you need the selector.');
        addToOutput(`; Usage: dig <selector>._domainkey.${domain} TXT`);
        addToOutput('; Example: dig google._domainkey.example.com TXT');
        return;
    }
    
    addToOutput(`; <<>> DiG 9.10.6 <<>> ${domain} ${type}`);
    addToOutput(';; global options: +cmd');
    addToOutput(';; Got answer:');
    addToOutput(`;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: ${Math.floor(Math.random() * 65535)}`);
    addToOutput(';; flags: qr rd ra; QUERY: 1, ANSWER: ?, AUTHORITY: 0, ADDITIONAL: 1');
    addToOutput('');
    addToOutput(';; QUESTION SECTION:');
    addToOutput(`;${domain}.\t\tIN\t${type}`);
    addToOutput('');

    try {
      const startTime = performance.now();
      const response = await fetch(`https://dns.google/resolve?name=${domain}&type=${type}`);
      const endTime = performance.now();
      const queryTime = Math.round(endTime - startTime);

      if (!response.ok) {
        addToOutput(`;; connection timed out; no servers could be reached`, 'command-error');
        return;
      }

      const data = await response.json();

      if (data.Status !== 0) {
         addToOutput(`;; ->>HEADER<<- status: ${data.Status === 3 ? 'NXDOMAIN' : 'SERVFAIL'}`);
      }

      if (data.Answer) {
        addToOutput(';; ANSWER SECTION:');
        data.Answer.forEach(record => {
          // Map type number to name if possible, or use raw type
          let typeName = 'A';
          if (record.type === 1) typeName = 'A';
          if (record.type === 28) typeName = 'AAAA';
          if (record.type === 5) typeName = 'CNAME';
          if (record.type === 15) typeName = 'MX';
          if (record.type === 16) typeName = 'TXT';
          if (record.type === 2) typeName = 'NS';
          if (record.type === 6) typeName = 'SOA';
          
          // If user requested a specific type, use that label, otherwise guess
          if (type !== 'A' && type !== 'AAAA') typeName = type;

          addToOutput(`${record.name}\t${record.TTL}\tIN\t${typeName}\t${record.data}`);
        });
        addToOutput('');
      }

      addToOutput(`;; Query time: ${queryTime} msec`);
      addToOutput(`;; SERVER: 8.8.8.8#53(8.8.8.8)`);
      addToOutput(`;; WHEN: ${new Date().toString()}`);
      addToOutput(`;; MSG SIZE  rcvd: ${JSON.stringify(data).length}`);
      addToOutput(`;; Data provided by Google Public DNS (dns.google)`);

    } catch (error) {
      addToOutput(`;; connection failed: ${error.message}`, 'command-error');
    }
    
    terminalWindow.scrollTop = terminalWindow.scrollHeight;
  }

  async function handleOsint(args) {
    if (args.length === 0) {
      addToOutput('Usage: osint <ip_address|domain>');
      return;
    }

    let ip = args[0];
    
    // Check if input is a domain (not an IP)
    const isIpv4 = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(ip);
    const isIpv6 = ip.includes(':');
    
    if (!isIpv4 && !isIpv6) {
        addToOutput(`Resolving domain ${ip}...`);
        try {
            // Try IPv4 first
            let dnsResp = await fetch(`https://dns.google/resolve?name=${ip}&type=A`);
            let dnsData = await dnsResp.json();
            let resolved = false;

            if (dnsData.Answer) {
                const aRecord = dnsData.Answer.find(r => r.type === 1);
                if (aRecord) {
                    ip = aRecord.data;
                    addToOutput(`Resolved to IPv4: ${ip}`);
                    resolved = true;
                }
            }

            // If no IPv4, try IPv6
            if (!resolved) {
                dnsResp = await fetch(`https://dns.google/resolve?name=${ip}&type=AAAA`);
                dnsData = await dnsResp.json();
                if (dnsData.Answer) {
                    const aaaaRecord = dnsData.Answer.find(r => r.type === 28);
                    if (aaaaRecord) {
                        ip = aaaaRecord.data;
                        addToOutput(`Resolved to IPv6: ${ip}`);
                        resolved = true;
                    }
                }
            }

            if (!resolved) {
                throw new Error('Could not resolve domain (No A or AAAA records found)');
            }

        } catch (e) {
            addToOutput(`DNS Error: ${e.message}`, 'command-error');
            return;
        }
    }

    addToOutput(`Gathering intelligence for ${ip}...`);
    addToOutput('----------------------------------------');

    // 1. Geo/Network Info (ipwho.is)
    try {
      const geoResponse = await fetch(`https://ipwho.is/${ip}`);
      const geoData = await geoResponse.json();

      if (geoData.success) {
        addToOutput(`[Network Info]`);
        addToOutput(`  IP Type: ${geoData.type}`);
        addToOutput(`  Location: ${geoData.city}, ${geoData.region}, ${geoData.country} ${geoData.flag ? geoData.flag.emoji : ''}`);
        addToOutput(`  Continent: ${geoData.continent} (${geoData.continent_code})`);
        addToOutput(`  Coordinates: ${geoData.latitude}, ${geoData.longitude}`);
        if (geoData.postal) addToOutput(`  Postal Code: ${geoData.postal}`);
        if (geoData.calling_code) addToOutput(`  Calling Code: +${geoData.calling_code}`);
        
        addToOutput(`  ISP: ${geoData.connection.isp}`);
        addToOutput(`  ASN: AS${geoData.connection.asn} (${geoData.connection.org})`);
        if (geoData.connection.domain) addToOutput(`  Domain: ${geoData.connection.domain}`);
        
        if (geoData.timezone) {
            addToOutput(`  Timezone: ${geoData.timezone.id} (${geoData.timezone.utc})`);
            addToOutput(`  Local Time: ${geoData.timezone.current_time}`);
        }
      } else {
        addToOutput(`[Network Info] Failed: ${geoData.message}`, 'command-error');
      }
    } catch (e) {
      addToOutput(`[Network Info] Error: ${e.message}`, 'command-error');
    }

    // 2. Tor Node Check (Onionoo)
    try {
        const torResponse = await fetch(`https://onionoo.torproject.org/details?search=${ip}`);
        const torData = await torResponse.json();
        
        if (torData.relays.length > 0 || torData.bridges.length > 0) {
            addToOutput(`[Tor Check]`);
            addToOutput(`  ⚠️  CONFIRMED TOR NODE`, 'command-error');
            if (torData.relays.length > 0) {
                const relay = torData.relays[0];
                addToOutput(`  Nickname: ${relay.nickname}`);
                addToOutput(`  Platform: ${relay.platform}`);
                addToOutput(`  Contact: ${relay.contact || 'None'}`);
            }
        }
    } catch (e) {
        // Silent fail for Tor check if network error, or log it
        // addToOutput(`[Tor Check] Error: ${e.message}`, 'command-error');
    }

    // 3. Reputation/Spam Check (StopForumSpam)
    try {
      const spamResponse = await fetch(`https://api.stopforumspam.org/api?ip=${ip}&json`);
      const spamData = await spamResponse.json();

      addToOutput(`[Reputation Check]`);
      if (spamData.success) {
        if (spamData.ip.appears) {
           addToOutput(`  ⚠️  FLAGGED: This IP appears in the spam database!`, 'command-error');
           addToOutput(`  Frequency: ${spamData.ip.frequency}`);
           addToOutput(`  Last Seen: ${spamData.ip.lastseen}`);
           if (spamData.ip.confidence) addToOutput(`  Confidence: ${spamData.ip.confidence}%`);
           if (spamData.ip.delegated) addToOutput(`  Delegated: ${spamData.ip.delegated}`);
           if (spamData.ip.country) addToOutput(`  Country: ${spamData.ip.country}`);
           if (spamData.ip.asn) addToOutput(`  ASN: ${spamData.ip.asn}`);
        } else {
           addToOutput(`  ✅  CLEAN: No recent spam reports found.`);
           addToOutput(`  Frequency: ${spamData.ip.frequency}`);
           addToOutput(`  Appears: ${spamData.ip.appears}`);
        }
      } else {
        addToOutput(`  Could not verify reputation.`);
      }
    } catch (e) {
      addToOutput(`[Reputation Check] Error: ${e.message}`, 'command-error');
    }
    
    addToOutput('----------------------------------------');
    addToOutput('Data provided by ipwho.is, onionoo.torproject.org, and stopforumspam.org');
    terminalWindow.scrollTop = terminalWindow.scrollHeight;
  }

  function processEntities(entities, indent = '') {
    entities.forEach(entity => {
      const roles = entity.roles ? entity.roles.join(', ') : 'Entity';
      const handle = entity.handle || '';
      
      // Extract vCard Data
      let name = '', org = '', email = '', phone = '';
      if (entity.vcardArray && entity.vcardArray[1]) {
        const vcard = entity.vcardArray[1];
        vcard.forEach(item => {
          if (item[0] === 'fn') name = item[3];
          if (item[0] === 'org') org = item[3];
          if (item[0] === 'email') email = item[3];
          if (item[0] === 'tel') phone = item[3];
        });
      }
      
      // Only print if we have meaningful data
      if (name || org || email || roles) {
        addToOutput(`${indent}${roles.toUpperCase()}: ${name || org || handle}`);
        if (org && org !== name) addToOutput(`${indent}  Org: ${org}`);
        if (email) addToOutput(`${indent}  Email: ${email}`);
        if (phone) addToOutput(`${indent}  Phone: ${phone}`);
      }
      
      // Recursive for nested entities (like abuse contacts inside registrar)
      if (entity.entities) {
        processEntities(entity.entities, indent + '  ');
      }
    });
  }
});
</script>
